(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{527:function(t,e,a){"use strict";a.r(e);var r=a(21),n=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"spring-boot-使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-使用"}},[t._v("#")]),t._v(" Spring Boot 使用")]),t._v(" "),a("h2",{attrs:{id:"构建系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建系统"}},[t._v("#")]),t._v(" 构建系统")]),t._v(" "),a("p",[t._v("Spring Boot 建议我们选择 Maven 或 Gradle 等支持依赖管理并且可以发布 artifacts 到 Maven Central 中央仓库的构建系统 。我们也可以让 Spring Boot 与其他构建系统（例如 Ant）一起工作，但它们并没有得到 Spring Boot 很好的支持。")]),t._v(" "),a("h3",{attrs:{id:"依赖管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖管理"}},[t._v("#")]),t._v(" 依赖管理")]),t._v(" "),a("p",[t._v("Spring Boot 的每个版本都提供了它所支持依赖项的精选列表，我们不需要在构建配置中为这些依赖项提供版本，因为 Spring Boot 会为我们管理。当我们升级 Spring Boot 版本时，这些依赖项也会以一致的方式升级。")]),t._v(" "),a("p",[t._v("如果需要，我们可以通过覆盖自己项目中的属性来覆盖各个依赖项。例如，我们如果要使用不同版本的 SLF4J 和 Spring Data，则需要在项目 POM 文件中添加以下内容：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<properties>\n    <slf4j.version>1.7.30</slf4j.version>\n    <spring-data-releasetrain.version>Moore-SR6</spring-data-releasetrain.version>\n</properties>\n\n")])])]),a("blockquote",[a("p",[a("strong",[t._v("Spring Boot 的每个版本都与 Spring Framework 的一个基础版本相关联，Spring Boot 强烈建议我们不要指定 Spring Framework 的版本。")])])]),t._v(" "),a("p",[t._v("精选列表包含可以与 Spring Boot 一起使用的所有 Spring 模块以及第三方库，该列表以 spring-boot-dependencies POM 的形式提供。")]),t._v(" "),a("h3",{attrs:{id:"starters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#starters"}},[t._v("#")]),t._v(" Starters")]),t._v(" "),a("p",[t._v("Starters（启动器） 是可以加入到我们应用程序里面的一系列实用的依赖项，无需搜索示例代码和复制粘贴大量的依赖描述就可以获得所需的所有 Spring 和相关技术的一站式商店。比如，我们想使用 Spring 和 JPA 进行数据库访问，就可以将 spring-boot-starter-data-jpa 依赖项加入到我们的项目中。")]),t._v(" "),a("p",[t._v("启动器包含使项目快速启动并运行的一组受管理的、支持传递的依赖。")]),t._v(" "),a("p",[t._v("所有的官方启动器都遵循类似的命名模式：spring-boot-starter-*，其中 * 是特定类型的应用程序，此命名结构旨在帮助我们在需要查找启动器时提供帮助。")]),t._v(" "),a("p",[t._v("第三方的 starter 不应该以 spring-boot 开头，因为它是为官方 Spring Boot 工作保留的，相反，第三方启动器通常以项目名称开头。比如，一个名为 thirdpartyproject 的第三方 starter 项目通常被命名为 thirdpartyproject-spring-boot-starter。")]),t._v(" "),a("p",[t._v("下面列出 Spring Boot 提供在 org.springframework.boot group 下比较常用的一些官方启动器：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("Name")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("核心启动器, 包括自动配置支持、日志和 YAML")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-amqp")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring AMQP 和 Rabbit MQ 的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-aop")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring AOP 和 AspectJ 的面向切面编程启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-batch")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Batch 批处理的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-cache")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Framework 缓存支持的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-data-elasticsearch")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Elasticsearch 搜索引擎 和 Spring Data Elasticsearch 的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-data-jdbc")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Data JDBC 的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-data-jpa")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Data JPA 的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-data-mongodb")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用面向文档的数据库 MongoDB 和 Spring Data MongoDB 的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-data-mongodb-reactive")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用面向文档的数据库 MongoDB 和 Spring Data MongoDB Reactive 的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-data-redis")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Data Redis 和 Lettuce 客户端 将 Redis key-value 数据存储的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-data-redis-reactive")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Data Redis reactive 和 Lettuce 客户端 将 Redis key-value 数据存储的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-data-rest")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Data REST 通过 REST 暴露 Spring Data 存储库的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-freemarker")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 FreeMarker 视图构建 MVC Web 应用程序的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-jdbc")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 JDBC 和 HikariCP 连接池的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-json")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("读写 json 的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-mail")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("支持使用 Java Mail 和 Spring Framework 的电子邮件发送启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-oauth2-client")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Security 的 OAuth2/OpenID Connect 客户端功能的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-oauth2-resource-server")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Security 的 OAuth2 资源服务器特性的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-quartz")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Quartz 调度器的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-security")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Security 的 启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-test")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用包括 JUnit Jupiter、Hamcrest 和 Mockito 在内的库测试 Spring Boot 应用程序的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-thymeleaf")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Thymeleaf 视图构建 MVC Web 应用程序的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-validation")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用带有 Hibernate Validator 的 Java Bean Validation 的 启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-web")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring MVC 构建 Web 应用程序的启动器，包括 RESTful 应用程序，使用 Tomcat 作为默认的嵌入式容器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-web-services")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Web Services 的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-webflux")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Framework 的响应式 Web 支持构建 WebFlux 应用程序的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-websocket")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Framework 的 WebSocket 支持构建 WebSocket 应用程序的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-actuator")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Spring Boot 的 Actuator 的启动器，它提供了生产就绪功能来帮助监控和管理应用程序")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-tomcat")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Tomcat 作为嵌入式 servlet 容器，是 spring-boot-starter-web 使用的默认 servlet 容器启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-jetty")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Jetty 作为嵌入式 servlet 容器的启动器，一个 spring-boot-starter-tomcat 替代方案")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-undertow")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Undertow 作为嵌入式 servlet 容器的启动器，一个 spring-boot-starter-tomcat 替代方案")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-reactor-netty")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Reactor Netty 作为嵌入式响应式 HTTP 服务器的启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-logging")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Logback 进行日志记录的启动器，默认的日志记录启动器")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring-boot-starter-log4j2")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("使用 Log4j2 进行日志记录的启动器，一个 spring-boot-starter-logging 的替代方案")])])])]),t._v(" "),a("h2",{attrs:{id:"代码结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码结构"}},[t._v("#")]),t._v(" 代码结构")]),t._v(" "),a("h3",{attrs:{id:"包命名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包命名"}},[t._v("#")]),t._v(" 包命名")]),t._v(" "),a("p",[t._v("当一个类不包含 package 声明时，它被认为在默认包中。我们通常不鼓励使用默认包，应避免使用，它可能会导致使用了 @ComponentScan、@ConfigurationPropertiesScan、@EntityScan 或 @SpringBootApplication 注解的 Spring Boot 应用程序出现特殊问题，因为每个 jar 中的每个类都会被扫描读取。Spring Boot 建议遵循 Java 推荐的包命名约定并使用反向域名（例如，io.github.xxyopen）。")]),t._v(" "),a("h3",{attrs:{id:"启动类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#启动类"}},[t._v("#")]),t._v(" 启动类")]),t._v(" "),a("p",[t._v("Spring Boot 建议将应用程序启动类放在其他类之上的根包中。@SpringBootApplication 注解通常放置在启动类上，它隐式地定义了一个基础的搜索包（根包）。使用根包的好处还包括只扫描本项目中的组件。")]),t._v(" "),a("p",[t._v("如果不想使用 @SpringBootApplication 注解，也可以用 @EnableAutoConfiguration 和 @ComponentScan 这两个注解来代替。")]),t._v(" "),a("p",[t._v("以下是一个典型的示例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("io\n +- github\n     +- xxyopen   \n        +- novel\n            +- NovelApplication.java -- 项目启动类\n            |\n            +- dao\n            |   +- BookDao.java \n            |   +- UserDao.java\n            | \n            +- service \n            |   +- BookService.java\n            |   +- UserService.java\n            |  \n            +- controller\n            |   +- UserController.java\n            |   +- UserController.java     \n                    \n")])])]),a("p",[t._v("NovelApplication.java 被定义成启动类, 带有 @SpringBootApplication 注解, 如下所示:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("@SpringBootApplication\npublic class NovelApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(NovelApplication.class, args);\n    }\n\n}\n")])])]),a("h2",{attrs:{id:"配置类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置类"}},[t._v("#")]),t._v(" 配置类")]),t._v(" "),a("p",[t._v("Spring Boot 支持基于 Java 的配置，虽然可以使用 XML 来配置 Spring 应用程序，但 SpringBoot 建议我们使用 @Configuration 类来配置我们的应用程序。定义 main 方法的 Spring Boot 启动类通常是一个 @Configuration 主配置类。")]),t._v(" "),a("p",[t._v("我们不需要把所有的配置都放到一个 @Configuration 配置类中，@Import 注解可用于导入其他的配置类。我们还可以使用 @ComponentScan 自动扫描获取所有的 Spring 组件，包括 @Configuration 配置类。")]),t._v(" "),a("p",[t._v("如果我们需要使用基于 XML 的配置，Spring Boot 建议我们仍然从 @Configuration 类开始，然后使用 @ImportResource 注解来加载 XML 配置文件。")]),t._v(" "),a("p",[t._v("以下是一个 Redis 的配置类示例：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("@Configuration\n@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})\npublic class RedisConfiguration {\n\n    @Bean\n    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {\n        RedisTemplate<Object, Object> template = new RedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    }\n\n    @Bean\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {\n        StringRedisTemplate template = new StringRedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    }\n}\n")])])]),a("h2",{attrs:{id:"自动配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动配置"}},[t._v("#")]),t._v(" 自动配置")]),t._v(" "),a("p",[t._v("Spring Boot 自动配置会根据我们添加的 jar 依赖项自动配置我们的 Spring 应用程序。例如，如果 HSQLDB 在 classpath 类路径上，并且没有手动配置任何数据库连接 bean，那么 Spring Boot 会自动配置一个内存数据库。")]),t._v(" "),a("p",[t._v("自动配置生效的前提是我们需要向 @Configuration 配置类上添加 @EnableAutoConfiguration 或 @SpringBootApplication 注解来开启自动配置，Spring Boot 建议我们添加到主配置类（通常是定义 main 方法的启动类）上。")]),t._v(" "),a("p",[t._v("自动配置是非侵入性的。在任何时候，我们都可以定义自己的配置来替换自动配置的特定部分。例如，如果添加自己的 DataSource bean，则默认的嵌入式数据库支持会替换掉。")]),t._v(" "),a("p",[t._v("如果我们要了解当前正在应用哪些自动配置以及原因，可以使用 --debug 来启动应用程序。这样可以开启调试日志，并将条件报告打印到控制台。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$  mvn spring-boot:run --debug\n")])])]),a("p",[t._v("我们还可以通过使用 @SpringBootApplication 注解的 exclude 属性来禁用特定的自动配置类：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })\npublic class NovelApplication {\n\n}\n")])])]),a("p",[t._v("如果需要禁用的自动配置类不在 classpath 类路径上，我们还可以用注解的 excludeName 属性指定类的完全限定名。我们也可以使用 @EnableAutoConfiguration 而不是 @SpringBootApplication 注解的 exclude 或 excludeName 属性来禁用自动配置类。最后，我们还可以使用 spring.autoconfigure.exclude 配置属性来控制要禁用的自动配置类列表。")]),t._v(" "),a("h2",{attrs:{id:"依赖注入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖注入"}},[t._v("#")]),t._v(" 依赖注入")]),t._v(" "),a("p",[t._v("我们可以使用任何 Spring Framework 标准技术来定义我们的 beans 以及注入它们的依赖。Spring Boot 建议使用构造函数注入和使用 @ComponentScan 扫描 beans。")]),t._v(" "),a("p",[t._v("如果我们将应用程序启动类放在根包中，我们可以添加不带任何参数的 @ComponentScan 或 @SpringBootApplication（隐式包含 @ComponentScan） 注解。这样我们所有的应用程序组件（@Component、@Service、@Repository、@Controller等）都会自动注册为 Spring Bean。")]),t._v(" "),a("p",[t._v("以下是一个使用构造函数向一个 Spring bean 注入所需依赖的例子：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("@Service\npublic class MyAccountService implements AccountService {\n\n    private final RiskAssessor riskAssessor;\n\n    public MyAccountService(RiskAssessor riskAssessor) {\n        this.riskAssessor = riskAssessor;\n    }\n\n    // ...\n\n}\n")])])]),a("p",[t._v("如果一个 bean 有多个构造函数，需要使用 @Autowired 注解来标记我们想要 Spring 使用哪一个：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("@Service\npublic class MyAccountService implements AccountService {\n\n    private final RiskAssessor riskAssessor;\n\n    private final PrintStream out;\n\n    @Autowired\n    public MyAccountService(RiskAssessor riskAssessor) {\n        this.riskAssessor = riskAssessor;\n        this.out = System.out;\n    }\n\n    public MyAccountService(RiskAssessor riskAssessor, PrintStream out) {\n        this.riskAssessor = riskAssessor;\n        this.out = out;\n    }\n\n    // ...\n\n}\n")])])]),a("p",[a("strong",[t._v("注：依赖注入的字段被声明为 final 是为了表明它以后不能再被修改。")])]),t._v(" "),a("h2",{attrs:{id:"springbootapplication-注解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#springbootapplication-注解"}},[t._v("#")]),t._v(" @SpringBootApplication 注解")]),t._v(" "),a("p",[t._v("打开 SpringBootApplication 源文件可以发现单个 @SpringBootApplication 注解由以下三个注解组成：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("@EnableAutoConfiguration: 启用 Spring Boot 的自动配置机制")])]),t._v(" "),a("li",[a("p",[t._v("@ComponentScan ：在当前包下开启 @Component 扫描")])]),t._v(" "),a("li",[a("p",[t._v("@SpringBootConfiguration: 允许在 Spring 上下文中注册额外的 bean 或导入额外的配置类。Spring 标准注解 @Configuration 的替代方案，可以帮助我们在集成测试中进行配置检测。")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n    excludeFilters = {@Filter(\n    type = FilterType.CUSTOM,\n    classes = {TypeExcludeFilter.class}\n), @Filter(\n    type = FilterType.CUSTOM,\n    classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication {\n    @AliasFor(\n        annotation = EnableAutoConfiguration.class\n    )\n    Class<?>[] exclude() default {};\n\n    @AliasFor(\n        annotation = EnableAutoConfiguration.class\n    )\n    String[] excludeName() default {};\n\n    @AliasFor(\n        annotation = ComponentScan.class,\n        attribute = "basePackages"\n    )\n    String[] scanBasePackages() default {};\n\n    @AliasFor(\n        annotation = ComponentScan.class,\n        attribute = "basePackageClasses"\n    )\n    Class<?>[] scanBasePackageClasses() default {};\n\n    @AliasFor(\n        annotation = ComponentScan.class,\n        attribute = "nameGenerator"\n    )\n    Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;\n\n    @AliasFor(\n        annotation = Configuration.class\n    )\n    boolean proxyBeanMethods() default true;\n}\n')])])]),a("h2",{attrs:{id:"程序运行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序运行"}},[t._v("#")]),t._v(" 程序运行")]),t._v(" "),a("ol",[a("li",[t._v("从 IDE 导入代码运行")])]),t._v(" "),a("p",[t._v("使用 IntelliJ IDEA 或 Eclipse 等集成开发工具导入项目源码后运行。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("打包应用程序运行")])]),t._v(" "),a("p",[t._v("使用 Spring Boot Maven 插件打包源码成可执行 jar 后使用 java -jar 来运行应用程序。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("java -jar target/novel-0.0.1-SNAPSHOT.jar\n")])])]),a("p",[t._v("还可以在启用远程调试支持的情况下运行打包的应用程序，这样可以让调试器连接到打包的应用程序")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \\\n       -jar target/novel-0.0.1-SNAPSHOT.jar\n\n")])])]),a("ol",{attrs:{start:"3"}},[a("li",[t._v("使用 maven 插件运行")])]),t._v(" "),a("p",[t._v("Spring Boot Maven 插件包含一个可用于快速编译和运行应用程序的 run 目标，应用程序以分解的形式运行，就像在 IDE 中一样。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ mvn spring-boot:run\n")])])]),a("p",[t._v("如果想使用 MAVEN_OPTS 操作系统环境变量，可以使用如下命令：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ export MAVEN_OPTS = -Xmx1024m\n")])])]),a("h2",{attrs:{id:"开发者工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开发者工具"}},[t._v("#")]),t._v(" 开发者工具")]),t._v(" "),a("p",[t._v("Spring Boot 包含一组能够提升开发体验的工具 spring-boot-devtools，要获得该工具的支持，需要将以下的依赖添加到 Maven POM 文件中，以提供额外的开发时功能：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>true</optional>\n</dependency>\n")])])]),a("p",[a("strong",[t._v("注：在 Maven 中将依赖项的 optional 标签设置为 true 可防止 devtools 被传递到项目的其它模块中。运行完整打包的应用程序时，开发者工具会自动禁用。")])]),t._v(" "),a("h3",{attrs:{id:"诊断类加载问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#诊断类加载问题"}},[t._v("#")]),t._v(" 诊断类加载问题")]),t._v(" "),a("p",[t._v("重新启动功能是通过使用两个类加载器实现的，对于大多数应用程序来说，这种方法效果很好，但是，它有时会导致类加载问题，尤其是在多模块项目中。")]),t._v(" "),a("p",[t._v("要诊断类加载问题是否确实是由 devtools 及其两个类加载器引起的，可以尝试禁用重新启动功能，看是否能够解决问题，如果是，则需要自定义重启类加载器。")]),t._v(" "),a("h3",{attrs:{id:"属性默认值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性默认值"}},[t._v("#")]),t._v(" 属性默认值")]),t._v(" "),a("p",[t._v("Spring Boot 支持的几个库使用缓存来提高性能。例如，缓存已编译的模板引擎以避免重复解析模板文件。Spring MVC 可以在提供静态资源时将 HTTP 缓存标头添加到响应中。")]),t._v(" "),a("p",[t._v("虽然缓存在生产中非常有用，但在开发过程中可能会适得其反，使我们无法实时看到刚刚在应用程序中所做的更改。因此，spring-boot-devtools 默认禁用缓存选项。")]),t._v(" "),a("p",[t._v("缓存选项通常在 application.properties 文件中配置。例如，Thymeleaf 提供了 spring.thymeleaf.cache 属性。spring-boot-devtools 会自动应用合理的开发时配置，无需手动设置这些属性。")]),t._v(" "),a("p",[t._v("下面列出了所有的应用属性：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("Name")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("Default Value")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("server.error.include-binding-errors")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("always")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("server.error.include-message")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("always")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("server.error.include-stacktrace")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("always")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("server.servlet.jsp.init-parameters.development")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("true")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("server.servlet.session.persistent")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("true")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.freemarker.cache")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("false")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.groovy.template.cache")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("false")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.h2.console.enabled")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("true")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.mustache.servlet.cache")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("false")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.mvc.log-resolved-exception")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("true")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.reactor.debug")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("true")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.template.provider.cache")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("false")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.thymeleaf.cache")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("false")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.web.resources.cache.period")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("0")])])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("spring.web.resources.chain.cache")])]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[a("code",[t._v("false")])])])])]),t._v(" "),a("p",[t._v("我们可以在 application.properties 配置文件中通过设置 spring.devtools.add-properties = false 来禁用这些默认属性。")]),t._v(" "),a("h3",{attrs:{id:"自动重启"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动重启"}},[t._v("#")]),t._v(" 自动重启")]),t._v(" "),a("p",[t._v("当 classpath 类路径下的文件改变时，使用 spring-boot-devtools 的应用程序会自动重启，某些资源，例如静态资源和视图模板，不需要重新启动应用程序。")]),t._v(" "),a("p",[t._v("由于 DevTools 监控类路径资源，触发重启的唯一方法是更新类路径。无论我们使用的是 IDE 还是其中的一个构建插件，都必须重新编译修改后的文件以触发重新启动。更新类路径的方式取决于使用的工具：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在 Eclipse 中，保存修改后的文件会导致类路径更新并触发重新启动。")])]),t._v(" "),a("li",[a("p",[t._v("在 IntelliJ IDEA 中，构建项目 ( Build +→+ Build Project) 具有相同的效果。")])]),t._v(" "),a("li",[a("p",[t._v("如果使用构建插件，运行 mvn compile 命令将触发重新启动。")])])]),t._v(" "),a("p",[t._v("如果不想使用重启功能，可以使用 spring.devtools.restart.enabled 属性禁用它，在大多数情况下，我们可以在 application.properties 中设置此属性（这样做仍然会初始化重启类加载器，但它不会监视文件更改）")]),t._v(" "),a("p",[t._v("如果我们想完全禁用重启支持，则需要在调用 SpringApplication.run(…​) 之前将 spring.devtools.restart.enabled 的 System 属性设置为 false，如下所示：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class NovelApplication {\n\n    public static void main(String[] args) {\n        System.setProperty("spring.devtools.restart.enabled", "false");\n        SpringApplication.run(NovelApplication.class, args);\n    }\n\n}\n')])])]),a("h3",{attrs:{id:"实时重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实时重载"}},[t._v("#")]),t._v(" 实时重载")]),t._v(" "),a("p",[t._v("spring-boot-devtools 模块包括一个嵌入式 LiveReload 服务器，可用于在资源更改时触发浏览器刷新。LiveReload 浏览器扩展可从 livereload.com 免费获得，适用于 Chrome、Firefox 和 Safari 。")]),t._v(" "),a("p",[t._v("如果我们不想在应用程序运行时启动 LiveReload 服务器，我们可以将 spring.devtools.livereload.enabled 属性设置为 false.")]),t._v(" "),a("p",[t._v("要在文件更改时触发 LiveReload，必须启用自动重启。")]),t._v(" "),a("p",[a("strong",[t._v("注：一次只能运行一个 LiveReload 服务器，在启动应用程序之前，请确保没有其他 LiveReload 服务器正在运行。如果从 IDE 启动多个应用程序，则只有第一个具有 LiveReload 支持")])]),t._v(" "),a("h3",{attrs:{id:"全局设置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局设置"}},[t._v("#")]),t._v(" 全局设置")]),t._v(" "),a("p",[t._v("我们可以通过将以下任何文件添加到 $HOME/.config/spring-boot 目录来配置全局 devtools 设置：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("spring-boot-devtools.properties")])]),t._v(" "),a("li",[a("p",[t._v("spring-boot-devtools.yaml")])]),t._v(" "),a("li",[a("p",[t._v("spring-boot-devtools.yml")])])]),t._v(" "),a("p",[t._v("添加到这些文件的任何属性都适用于我们机器上使用 devtools 的所有Spring Boot 应用程序。")]),t._v(" "),a("p",[a("strong",[t._v("注：默认情况下，$HOME 是用户的主目录。要自定义此位置，请设置 SPRING_DEVTOOLS_HOME 环境变量或 spring.devtools.home 系统属性。")])]),t._v(" "),a("h3",{attrs:{id:"远程应用程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#远程应用程序"}},[t._v("#")]),t._v(" 远程应用程序")]),t._v(" "),a("p",[t._v("Spring Boot 开发者工具不仅限于本地开发，还可以在运行远程应用程序时使用多种功能，远程支持是可选的，因为启用它可能会带来安全风险。只有在受信任的网络上运行或使用 SSL 保护时才应启用它。")]),t._v(" "),a("p",[t._v("要启用它，需要确保 devtools 包含在重新打包的 jar 中，如以下所示：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("<build>\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n            <configuration>\n                <excludeDevtools>false</excludeDevtools>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n")])])]),a("p",[t._v("然后需要设置 spring.devtools.remote.secret 属性，与任何重要的密码一样，该值应该是唯一且强大的，以至于无法猜测或暴力破解。")]),t._v(" "),a("p",[t._v("远程 devtools 支持分两部分提供：接受连接的服务器端端点和在 IDE 中运行的客户端应用程序。设置 spring.devtools.remote.secret 属性时，服务端组件会自动启用，客户端组件必须手动启动。")]),t._v(" "),a("h2",{attrs:{id:"程序部署"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序部署"}},[t._v("#")]),t._v(" 程序部署")]),t._v(" "),a("p",[t._v("可执行 jar 可用于生产部署。由于它们是独立的，因此它们也非常适合于基于云的部署。")]),t._v(" "),a("p",[t._v("对于其它生产就绪功能，例如运行状况检查、审计和 REST 度量 或 JMX 端点等，需要添加 spring-boot-starter-actuator 依赖。")])])}),[],!1,null,null,null);e.default=n.exports}}]);