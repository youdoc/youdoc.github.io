(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{510:function(e,n,t){"use strict";t.r(n);var o=t(21),a=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"技术要点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#技术要点"}},[e._v("#")]),e._v(" 技术要点")]),e._v(" "),t("h2",{attrs:{id:"mysql-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-新特性"}},[e._v("#")]),e._v(" MySQL 新特性")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("新增 JSON 数据类型")])]),e._v(" "),t("p",[e._v("在 5.7.8 版本之后，MySQL 新增了一个原生的 JSON 数据类型，JSON 值将不再以字符串的形式存储，而是采用一种允许快速读取文本元素（document elements）的内部二进制（internal binary）格式；在 JSON 列插入或者更新的时候将会自动验证 JSON 文本，未通过验证的文本将产生一个错误信息。")]),e._v(" "),t("p",[e._v("之前如果要存储 JSON 类型的数据的话我们只能自己做 JSON.stringify() 和 JSON.parse() 的操作，而且没办法针对 JSON 内的数据进行查询操作，所有的操作必须读取出来 parse 之后进行，非常的麻烦。原生的 JSON 数据类型支持之后，我们就可以直接对 JSON 进行数据查询和修改等操作了，较之前会方便非常多。")]),e._v(" "),t("p",[e._v("MySQL 8 大幅改进了对 JSON 的支持，在主从复制中，新增参数 binlog_row_value_options，控制 JSON 数据的传输方式，允许对于 JSON 类型部分修改，在binlog中只记录修改的部分，减少JSON大数据在只有少量修改的情况下，对资源的占用。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("默认字符集由 latin1 变为 utf8mb4")])]),e._v(" "),t("p",[e._v("在 MySQL 8.0 版本之前，默认字符集为 latin1，utf8 指向的是 utf8mb3，8.0版本默认字符集为 utf8mb4，utf8 默认指向的也是 utf8mb4。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("MyISAM 系统表全部换成 InnoDB 表")])]),e._v(" "),t("p",[e._v("MySQL 8.0 版本之后系统表全部换成了事务型的 Innodb 表，默认的 MySQL 实例将不包含任何 MyISAM 表，除非手动创建 MyISAM 表。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("自增变量持久化")])]),e._v(" "),t("p",[e._v("在 MySQL 8.0 之前的版本，自增主键 AUTO_INCREMENT 的值如果大于 max(primary key)+1，在 MySQL 重启后，会重置 AUTO_INCREMENT=max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("DDL 原子化")])]),e._v(" "),t("p",[e._v("MySQL 8.0 版本之后 InnoDB 表的 DDL 支持事务完整性，要么成功要么回滚，例如，数据库里只有一个t1表，执行"),t("code",[e._v("drop table t1,t2")]),e._v("语句试图删除t1,t2两张表，在 5.7 中，执行报错，但是 t1 表被删除，在 8.0 中执行报错，但是 t1 表没有被删除，证明了 8.0 DDL操作的原子性，要么全部成功，要么失败回滚。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("参数修改持久化")])]),e._v(" "),t("p",[e._v("MySQL 8.0 版本支持在线修改全局参数并持久化，通过加上 PERSIST 关键字，可以将修改的参数持久化到新的配置文件（mysqld-auto.cnf）中，重启 MySQL 时，可以从该配置文件获取到最新的配置参数。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("group by 不再隐式排序")])]),e._v(" "),t("p",[e._v("MySQL 8.0 对于group by 字段不再隐式排序，如需要排序，必须显式加上 order by 子句。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("支持不可见索引")])]),e._v(" "),t("p",[e._v("MySQL 8.0 支持不可见索引， 使用INVISIBLE关键字在创建表或者进行表变更中设置索引是否可见，索引不可见只是在查询时优化器不使用该索引，即使使用 force index，优化器也不会使用该索引，同时优化器也不会报索引不存在的错误，因为索引仍然真实存在，在必要时，也可以快速的恢复成可见。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("新增 innodb_dedicated_server 参数")])]),e._v(" "),t("p",[e._v("MySQL 8.0 新增 innodb_dedicated_server 参数，能够让InnoDB根据服务器上检测到的内存大小自动配置 innodb_buffer_pool_size，innodb_log_file_size，innodb_flush_method 三个参数。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("增加角色管理")])]),e._v(" "),t("p",[e._v("MySQL 8.0 增加角色管理，通常，MySQL 数据库拥有多个相同权限集合的用户。以前，向多个用户授予和撤销权限的唯一方法是单独更改每个用户的权限，假如用户数量比较多的时候，这是非常耗时的，为了用户权限管理更容易，MySQL 提供了一个名为 role 的新对象，它是一个命名的特权集合。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("克隆功能")])]),e._v(" "),t("p",[e._v("MySQL 8.0 clone 插件提供从一个实例克隆数据的功能，克隆功能提供了更有效的方式来快速创建MySQL实例，用于自动搭建从节点，也可用于备份 innodb 表，增强了 MySQL InnoDB Cluster。")]),e._v(" "),t("p",[e._v("在 MySQL 克隆功能出现之前，如果想将一个单机MySQL实例升级为高可用实例，或者一个 MySQL 节点由于硬件故障等原因需要重建时首先需要通过 xtrabackup 或mydumper 等物理或逻辑备份工具从正常的 MySQL 节点上进行一个全量备份，然后基于这个全量备份配置正确的 Binlog 相关参数，最后通过 change master to 和 start slave 等命令使新建的 MySQL 节点与所需的 MySQL 节点建立复制关系等待一系列复杂的操作。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("binlog 日志压缩")])]),e._v(" "),t("p",[e._v("MySQL 从 8.0.20 增加了 binlog 日志事务压缩功能，开启压缩功能后，将事务信息使用 zstd 算法进行压缩，然后再写入 binlog 日志文件，降低了原文件占用的磁盘空间和网络带宽传输。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("连接管理")])]),e._v(" "),t("p",[e._v("在 MySQL 8.0 版本中，对连接管理这一块，先后做了两个比较大的改变：一个是允许额外连接，另一个是专用的管理端口。在 MySQL 8.0 版本中，在当前连接数达到最大连接数时，服务端允许1个额外连接，可以让具有 CONNECTION_ADMIN 权限的用户连接进来，并且允许具有 SERVICE_CONNECTION_ADMIN 权限的用户，通过特定的 IP 和 PORT 连接上来，且没有连接数限制。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("取消 Query Cache")])]),e._v(" "),t("p",[e._v("MySQL 8.0 开始，取消了查询缓存，经过时间的考验，MySQL 的工程团队发现启用缓存的好处并不多。")]),e._v(" "),t("p",[e._v("首先，查询缓存的效果取决于缓存的命中率，只有命中缓存的查询效果才能有改善，因此无法预测其性能；其次，查询缓存的另一个大问题是它受到单个互斥锁的保护，在具有多个内核的服务器上，大量查询会导致大量的互斥锁争用；最后，相对来说，缓存越靠近客户端，获得的好处越大。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("允许禁用 redo log")])]),e._v(" "),t("p",[e._v("MySQL 8.0.21 开始可以禁用 redo log 来提升数据库的写性能，但降低了安全性，适用于某些对安全要求较低的场景。")])])]),e._v(" "),t("h2",{attrs:{id:"jdk-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jdk-新特性"}},[e._v("#")]),e._v(" JDK 新特性")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("引入模块")])]),e._v(" "),t("p",[e._v("Java 9 开始引入了模块（Module），目的是为了管理依赖。使用模块可以按需打包 JRE 和进一步限制类的访问权限。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("接口支持私有方法")])]),e._v(" "),t("p",[e._v("JAVA 9 开始，接口里可以添加私有方法，JAVA 8 对接口增加了默认方法的支持，在 JAVA 9 中对该功能又来了一次升级，现在可以在接口里定义私有方法，然后在默认方法里调用接口的私有方法。这样一来，既可以重用私有方法里的代码，又可以不公开代码。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("匿名内部类支持钻石（diamond）运算符")])]),e._v(" "),t("p",[e._v("JAVA 5 就引入了泛型（generic），到了 JAVA 7 开始支持钻石（diamond）运算符：<>，可以自动推断泛型的类型；但是这个自动推断类型的钻石运算符不支持匿名内部类，在 JAVA 9 中也对匿名内部类做了支持。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("增强的 try-with-resources")])]),e._v(" "),t("p",[e._v("JAVA 7 中增加了try-with-resources的支持，可以自动关闭资源，但需要声明多个资源变量时，需要在 try 中写多个变量的创建过程，JAVA 9 中对这个功能进行了增强，可以引用 try 代码块之外的变量来自动关闭。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("弃用 new Integer()")])]),e._v(" "),t("p",[e._v("JAVA 9 开始弃用了 new Integer() 的方式来创建 Integer 对象，推荐通过静态工厂 Integer.valueOf() 的方式来替代，其它包装类类似。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("局部变量的自动类型推断（var）")])]),e._v(" "),t("p",[e._v("JAVA 10 带来了一个很有意思的语法 - var，它可以自动推断局部变量的类型，以后再也不用写类型了，也不用靠 lombok 的 var 注解增强了，不过这个只是语法糖，编译后变量还是有类型的，使用时还是考虑下可维护性的问题，不然写多了可就成 JavaScript 风格了。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("Lambda 中的自动类型推断（var）")])]),e._v(" "),t("p",[e._v("JAVA 11 中对 Lambda 语法也支持了 var 这个自动类型推断的变量，通过 var 变量还可以增加额外的注解。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("java 命令增强")])]),e._v(" "),t("p",[e._v("以前编译一个 java 文件时，需要先 javac 编译为 class，然后再用 java 执行，JAVA 11 之后可以直接使用 java 命令。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("Java Flight Recorder 开源")])]),e._v(" "),t("p",[e._v("「Java Flight Recorder」 是个非常好用的调试诊断工具，不过之前是在 Oracle JDK 中， JAVA 11 后就开源了，OpenJDK 现在也可以用这个功能。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("更简洁的 switch 语法")])]),e._v(" "),t("p",[e._v("JAVA 12 和 13 分别增强了 switch 的语法。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("instanceof 增强")])]),e._v(" "),t("p",[e._v("之前处理动态类型碰上要强转时，需要先 instanceof 判断一下，然后再强转为该类型处理，JAVA 12 之后 instanceof 支持直接类型转换了，不需要再来一次额外的强转。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("文本块（Text Block）的支持")])]),e._v(" "),t("p",[e._v("JAVA 13 中帮你解决了"),t("code",[e._v("大段带换行符的字符串报文")]),e._v('的问题，增加了文本块（"""）的支持，可以不通过换行符换行拼字符串，而且不需要转义特殊字符，就像用模板一样。')])]),e._v(" "),t("li",[t("p",[t("code",[e._v("新增 record 类型")])]),e._v(" "),t("p",[e._v("JAVA 14 新增 record 类型，干掉复杂的 POJO 类，一般我们创建一个 POJO 类，需要定义属性列表，构造函数，getter/setter方法，比较麻烦，JAVA 14 为我们带来了一个便捷的创建类的方式 - record。")]),e._v(" "),t("p",[e._v("不过这个只是一个语法糖，编译后还是一个 Class，和普通的 Class 区别不大。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("更直观的 NullPointerException 提示")])]),e._v(" "),t("p",[e._v("JAVA 14 优化了 NullPointerException 的提示，让你更容易定位到哪个对象为空。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("新增 jpackage 打包工具")])]),e._v(" "),t("p",[e._v("JAVA 14 新增 jpackage 打包工具，可以直接打包二进制程序，再也不用装 JRE 了。")]),e._v(" "),t("p",[e._v("之前如果想构建一个可执行的程序，还需要借助三方工具，将 JRE 一起打包，或者让客户电脑也装一个 JRE 才可以运行我们的 JAVA 程序。")]),e._v(" "),t("p",[e._v("现在 JAVA 直接内置了 jpackage 打包工具，帮助你一键打包二进制程序包。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("新增封闭（Sealed ）类")])]),e._v(" "),t("p",[e._v("JAVA 的继承目前只能选择允许继承和不允许继承（final 修饰），JAVA 15 新增了一个封闭（Sealed ）类的特性，可以指定某些类才可以继承。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("新增垃圾回收器")])]),e._v(" "),t("p",[e._v("JAVA 15 中，两款垃圾回收器ZGC 和 Shenandoah 正式登陆（默认 G1 ），性能更强，延迟更低。")])])]),e._v(" "),t("p",[t("strong",[e._v("注：Spring Framework 6 和 Spring Boot 3 的应用程序运行时至少需要JDK 17。")])]),e._v(" "),t("h2",{attrs:{id:"springboot-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot-新特性"}},[e._v("#")]),e._v(" SpringBoot 新特性")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("优雅关机")])]),e._v(" "),t("p",[e._v("Spring Boot 2.3.0 配置关机缓冲时间后，在关闭时，Web服务器将不再允许新请求，并且将等待缓冲时间以使活动请求完成。")]),e._v(" "),t("p",[e._v("目前内置的四个嵌入式 Web 服务器（Jetty，Reactor Netty，Tomcat和Undertow）以及响应式和基于 Servlet 的 Web 应用程序都支持优雅关机。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("Docker 支持")])]),e._v(" "),t("p",[e._v("Spring Boot 2.3.0 添加了部分功能用来帮助将 Spring Boot 应用直接打包到 Docker 镜像。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("支持 Cloud Native Buildpacks 构建镜像；")])]),e._v(" "),t("li",[t("p",[e._v("maven 插件 增加 spring-boot:build-image 、gradle 增加 bootBuildImage task 帮助快速构建镜像；")])]),e._v(" "),t("li",[t("p",[e._v("支持 jar 分层，更好的优化打包镜像过程。")])])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("全新的配置文件处理")])]),e._v(" "),t("p",[e._v("使用"),t("code",[e._v("---")]),e._v("在一个 yml 文件中分割多个配置，如果启用多个配置中有一样的配置项会相互覆盖，在 Spring Boot 2.4.0 版本中声明在最后面的会覆盖前面的配置。在 Spring Boot 2.4.0 之前的版本中取决于"),t("code",[e._v("spring.profiles.active")]),e._v("中声明的顺序。")]),e._v(" "),t("p",[e._v("Spring Boot 2.4.0 版本之前使用文件名"),t("code",[e._v("application-{profile}")]),e._v("的方式指定配置标识，使用"),t("code",[e._v("spring.profiles.active")]),e._v("开启配置；Spring Boot 2.4.0 版本的用法是使用"),t("code",[e._v("spring.config.activate.on-profile")]),e._v("来指定配置标识，"),t("code",[e._v("spring.profiles.active")]),e._v("不能和它配置在同一个配置块中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("spring:\n  profiles:\n    active: dev\n---\nspring:\n  config:\n    activate:\n      on-profile: dev\nsecret：dev-password\n")])])]),t("p",[e._v("Spring Boot 2.4.0 版本以前使用"),t("code",[e._v("spring.profiles")]),e._v("和"),t("code",[e._v("spring.profiles.include")]),e._v("配置组合，Spring Boot 2.4.0 版本之后，使用"),t("code",[e._v("spring.profiles.group")]),e._v("来配置组合。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("spring:\n  profiles:\n    active:\n      - dev\n    group:\n      dev:\n        - devdb\n        - devmq\n      test:\n        - testdb\n        - testmq\n---\nspring:\n  config:\n    activate:\n      on-profile: dev\nsecret: dev-password\n---\nspring:\n  config:\n    activate:\n      on-profile: devdb\ndb: devdb\n---\nspring:\n  config:\n    activate:\n      on-profile: devmq\nmq: devmq        \n")])])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("默认禁止循环依赖")])]),e._v(" "),t("p",[e._v("我们都知道，如果两个 Bean 互相注入对方就会存在循环引用问题，Spring Boot 2.6.0 这个版本已经默认禁止 Bean 之间的循环引用，如果存在循环引用就会启动失败报错。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("支持自定义脱敏规则")])]),e._v(" "),t("p",[e._v("Spring Boot 2.6.0 版本可以清理 /env 和 /configprops 端点中存在的敏感值。另外，还可以通过添加类型为 SanitizingFunction 的 @Bean 类来配置自定义清理规则。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("重要端点变更")])]),e._v(" "),t("p",[e._v("Spring Boot 2.6.0版本的环境变量 /env 端点已经默认不开放了，另外 Spring Boot 下的 /info 端点现在可以公开 Java 运行时信息了。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("Redis 连接池")])]),e._v(" "),t("p",[e._v("当 commons-pool2 在类路径下时，Redis（包括：Jedis 和 Lettuce）在 Spring Boot 2.6.0 之后的版本会自动开启连接池，也可以设置禁用连接池。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("最低 Java 要求")])]),e._v(" "),t("p",[e._v("从Spring Boot 3.0 开始，Java 17 是最低版本，Java 8 不再被兼容。到正式版发行的时候 Java 19 也应该发行了。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("Jakarta EE 9")])]),e._v(" "),t("p",[e._v("Spring Boot 依赖于 Jakarta EE（原名 Java EE） 规范，3.0 已经升级到 Jakarta EE 9 版本。因此 Spring Boot 3.0 会使用 Servlet 5.0 规范和 JPA 3.0 规范。相关的三方依赖如果不支持这些规范，将减少或者移除这些依赖。所以相关的三方依赖请尽快根据 Jakarta EE 9 进行版本迭代。基于这个原因，目前不支持Jakarta EE 9 的类库将被移除，包含了一些知名三方类库，例如 EhCache3、Jersey、JOOQ、Thymeleaf 等等，直到这些类库适配 Jakarta EE 9。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("声明式 HTTP 客户端")])]),e._v(" "),t("p",[e._v("Spring 6（Spring Boot 3） 开始支持新的声明式 HTTP 客户端。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("新的 @AutoConfiguration 类")])]),e._v(" "),t("p",[e._v("Spring Boot 2.7/3 开始，@AutoConfiguration 类由 "),t("code",[e._v("META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports")]),e._v("文件而不再是 "),t("code",[e._v("META-INF/spring.factories")]),e._v(" 文件配置。")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("@ConfigurationProperties 构造函数绑定")])]),e._v(" "),t("p",[e._v("Spring 6（Spring Boot 3） 开始，@ConfigurationProperties 类支持新的构造函数绑定，而无需显式 @ConstructorBinding。")])])]),e._v(" "),t("h2",{attrs:{id:"全新的-elasticsearch-java-api-client"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#全新的-elasticsearch-java-api-client"}},[e._v("#")]),e._v(" 全新的 Elasticsearch Java API Client")]),e._v(" "),t("p",[e._v("Elasticsearch Java API Client 是自 7.16 版本开始稳定发布的官方 Java API 客户端。该客户端为所有 Elasticsearch API 提供强类型请求和响应。主要特性如下：")]),e._v(" "),t("ul",[t("li",[e._v("所有 Elasticsearch API 的强类型请求和响应。")]),e._v(" "),t("li",[e._v("所有 API 的阻塞和异步版本。")]),e._v(" "),t("li",[e._v("在创建复杂的嵌套结构时，使用流利的构建器和功能模式允许编写简洁易读的代码。")]),e._v(" "),t("li",[e._v("通过使用对象映射器（例如 Jackson）或任何 JSON-B 实现来无缝集成应用程序类。")]),e._v(" "),t("li",[e._v("将协议处理委托给 http 客户端，例如 "),t("a",{attrs:{href:"https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/8.2/java-rest-low.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java Low Level REST Client "),t("OutboundLink")],1),e._v("，该客户端负责处理所有传输级别的问题：HTTP 连接池、重试、节点发现等。")])]),e._v(" "),t("p",[e._v("Elasticsearch Java API Client 是一个全新的客户端库，与旧的 High Level Rest Client (HLRC) 没有任何关系。它提供了一个独立于 Elasticsearch 服务器代码的库，并为所有 Elasticsearch 功能提供了一个非常一致且更易于使用的 API。")]),e._v(" "),t("h3",{attrs:{id:"安装要求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装要求"}},[e._v("#")]),e._v(" 安装要求")]),e._v(" "),t("ul",[t("li",[e._v("Java 8 或更高版本。")]),e._v(" "),t("li",[e._v("一个 JSON 对象映射库，允许我们应用程序类与 Elasticsearch API 无缝集成。Java API Client 支持 Jackson 或 Eclipse Yasson 等 JSON-B 库 。")])]),e._v(" "),t("h3",{attrs:{id:"安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[e._v("#")]),e._v(" 安装")]),e._v(" "),t("p",[e._v("添加以下的 maven 依赖来安装 Java API Client：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<dependencies>\n\n    <dependency>\n      <groupId>co.elastic.clients</groupId>\n      <artifactId>elasticsearch-java</artifactId>\n      <version>8.2.0</version>\n    </dependency>\n\n    <dependency>\n      <groupId>com.fasterxml.jackson.core</groupId>\n      <artifactId>jackson-databind</artifactId>\n      <version>2.12.3</version>\n    </dependency>\n\n  </dependencies>\n\n")])])]),t("h3",{attrs:{id:"连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[e._v("#")]),e._v(" 连接")]),e._v(" "),t("p",[e._v("Java API Client 围绕三个主要组件构建：")]),e._v(" "),t("ul",[t("li",[e._v("API 客户端类。它们为 Elasticsearch API 提供强类型数据结构和方法。由于 Elasticsearch API 很大，它以功能组（也称为“命名空间”）的形式构成，每个组都有自己的客户端类。Elasticsearch 核心功能在 ElasticsearchClient 类中实现。")]),e._v(" "),t("li",[e._v("JSON 对象映射器。将应用程序类映射到 JSON 并将它们与 API 客户端无缝集成。")]),e._v(" "),t("li",[e._v("传输层实现。这是所有 HTTP 请求处理发生的地方。")])]),e._v(" "),t("p",[e._v("以下代码片段创建并将这三个组件连接在一起：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 1. Create the low-level client\nRestClient restClient = RestClient.builder(\nnew HttpHost("localhost", 9200)).build();\n\n// 2. Create the transport with a Jackson mapper\nElasticsearchTransport transport = new RestClientTransport(\nrestClient, new JacksonJsonpMapper());\n\n// 3. And create the API client\nElasticsearchClient client = new ElasticsearchClient(transport);\n')])])]),t("h3",{attrs:{id:"spring-boot-中使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring-boot-中使用"}},[e._v("#")]),e._v(" Spring Boot 中使用")]),e._v(" "),t("ol",[t("li",[e._v("在配置文件 application.yml 中配置如下的 Elasticsearch 连接信息：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("spring:\n  elasticsearch:\n    uris:\n      - https://my-deployment-ce7ca3.es.us-central1.gcp.cloud.es.io:9243\n    username: elastic\n    password: qTjgYVKSuExX\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("因为我们使用的是 Spring Boot 项目，当我们引入了 Java API Client 的 maven 相关依赖时，Spring Boot 的自动配置类 "),t("code",[e._v("ElasticsearchRestClientAutoConfiguration")]),e._v(" 生效，会自动为我们配置一个 RestClient。所以上一节连接三步骤的第一步"),t("code",[e._v("Create the low-level client")]),e._v("可以省略。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@AutoConfiguration\n@ConditionalOnClass({RestClientBuilder.class})\n@EnableConfigurationProperties({ElasticsearchProperties.class, ElasticsearchRestClientProperties.class})\n@Import({RestClientBuilderConfiguration.class, RestHighLevelClientConfiguration.class, RestClientFromRestHighLevelClientConfiguration.class, RestClientConfiguration.class, RestClientSnifferConfiguration.class})\npublic class ElasticsearchRestClientAutoConfiguration {\n    public ElasticsearchRestClientAutoConfiguration() {\n    }\n}\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[e._v("添加我们自己的 Elasticsearch 配置类，配置一个 ElasticsearchClient 如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n * elasticsearch 相关配置\n *\n * @author xiongxiaoyang\n * @date 2022/5/23\n */\n@Configuration\n@ConditionalOnProperty(prefix = "spring.elasticsearch", name = "enable", havingValue = "true")\n@RequiredArgsConstructor\npublic class EsConfig {\n\n    @Bean\n    public ElasticsearchClient elasticsearchClient(RestClient restClient) {\n\n        // Create the transport with a Jackson mapper\n        ElasticsearchTransport transport = new RestClientTransport(\n                restClient, new JacksonJsonpMapper());\n\n        // And create the API client\n        return new ElasticsearchClient(transport);\n    }\n\n}\n')])])]),t("h3",{attrs:{id:"使用示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用示例"}},[e._v("#")]),e._v(" 使用示例")]),e._v(" "),t("ol",[t("li",[e._v("批量插入数据")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public void saveToEs() {\n        QueryWrapper<BookInfo> queryWrapper = new QueryWrapper<>();\n        List<BookInfo> bookInfos;\n        long maxId = 0;\n        for(;;) {\n            queryWrapper.clear();\n            queryWrapper\n                    .orderByAsc(DatabaseConsts.CommonColumnEnum.ID.getName())\n                    .gt(DatabaseConsts.CommonColumnEnum.ID.getName(), maxId)\n                    .last(DatabaseConsts.SqlEnum.LIMIT_30.getSql());\n            bookInfos = bookInfoMapper.selectList(queryWrapper);\n            if (bookInfos.isEmpty()) {\n                break;\n            }\n            BulkRequest.Builder br = new BulkRequest.Builder();\n\n            for (BookInfo book : bookInfos) {\n                EsBookDto esBook = buildEsBook(book);\n                br.operations(op -> op\n                        .index(idx -> idx\n                                .index(EsConsts.IndexEnum.BOOK.getName())\n                                .id(book.getId().toString())\n                                .document(esBook)\n                        )\n                ).timeout(Time.of(t -> t.time("10s")));\n                maxId = book.getId();\n            }\n\n            BulkResponse result = elasticsearchClient.bulk(br.build());\n\n            // Log errors, if any\n            if (result.errors()) {\n                log.error("Bulk had errors");\n                for (BulkResponseItem item : result.items()) {\n                    if (item.error() != null) {\n                        log.error(item.error().reason());\n                    }\n                }\n            }\n\n        }\n\n    }\n')])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("全文检索")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@SneakyThrows\n@Override\npublic RestResp<PageRespDto<BookInfoRespDto>> searchBooks(BookSearchReqDto condition) {\n\n    SearchResponse<EsBookDto> response = esClient.search(s -> {\n\n                SearchRequest.Builder searchBuilder = s.index(EsConsts.IndexEnum.BOOK.getName());\n                buildSearchCondition(condition, searchBuilder);\n                // 排序\n                if (!StringUtils.isBlank(condition.getSort())) {\n                    searchBuilder.sort(o ->\n                            o.field(f -> f.field(condition.getSort()).order(SortOrder.Desc))\n                    );\n                }\n                // 分页\n                searchBuilder.from((condition.getPageNum() - 1) * condition.getPageSize())\n                        .size(condition.getPageSize());\n\n                return searchBuilder;\n            },\n            EsBookDto.class\n    );\n\n    TotalHits total = response.hits().total();\n\n    List<BookInfoRespDto> list = new ArrayList<>();\n    List<Hit<EsBookDto>> hits = response.hits().hits();\n    for (Hit<EsBookDto> hit : hits) {\n        EsBookDto book = hit.source();\n        list.add(BookInfoRespDto.builder()\n                .id(book.getId())\n                .bookName(book.getBookName())\n                .categoryId(book.getCategoryId())\n                .categoryName(book.getCategoryName())\n                .authorId(book.getAuthorId())\n                .authorName(book.getAuthorName())\n                .wordCount(book.getWordCount())\n                .lastChapterName(book.getLastChapterName())\n                .build());\n    }\n    return RestResp.ok(PageRespDto.of(condition.getPageNum(), condition.getPageSize(), total.value(), list));\n\n}\n\n/**\n * 构建查询条件\n */\nprivate void buildSearchCondition(BookSearchReqDto condition, SearchRequest.Builder searchBuilder) {\n\n    BoolQuery boolQuery = BoolQuery.of(b -> {\n\n        if (!StringUtils.isBlank(condition.getKeyword())) {\n            // 关键词匹配\n            b.must((q -> q.multiMatch(t -> t\n                    .fields("bookName^2","authorName^1.8","bookDesc^0.1")\n                    .query(condition.getKeyword())\n            )\n            ));\n        }\n\n        // 精确查询\n        if (Objects.nonNull(condition.getWorkDirection())) {\n            b.must(TermQuery.of(m -> m\n                    .field("workDirection")\n                    .value(condition.getWorkDirection())\n            )._toQuery());\n        }\n\n        if (Objects.nonNull(condition.getCategoryId())) {\n            b.must(TermQuery.of(m -> m\n                    .field("categoryId")\n                    .value(condition.getCategoryId())\n            )._toQuery());\n        }\n\n        // 范围查询\n        if (Objects.nonNull(condition.getWordCountMin())) {\n            b.must(RangeQuery.of(m -> m\n                    .field("wordCount")\n                    .gte(JsonData.of(condition.getWordCountMin()))\n            )._toQuery());\n        }\n\n        if (Objects.nonNull(condition.getWordCountMax())) {\n            b.must(RangeQuery.of(m -> m\n                    .field("wordCount")\n                    .lt(JsonData.of(condition.getWordCountMax()))\n            )._toQuery());\n        }\n\n        if (Objects.nonNull(condition.getUpdateTimeMin())) {\n            b.must(RangeQuery.of(m -> m\n                    .field("lastChapterUpdateTime")\n                    .gte(JsonData.of(condition.getUpdateTimeMin().getTime()))\n            )._toQuery());\n        }\n\n        return b;\n\n    });\n\n    searchBuilder.query(q -> q.bool(boolQuery));\n\n}\n')])])])])}),[],!1,null,null,null);n.default=a.exports}}]);