(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{514:function(e,a,t){"use strict";t.r(a);var n=t(21),s=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"更多"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更多"}},[e._v("#")]),e._v(" 更多")]),e._v(" "),t("h2",{attrs:{id:"git-提交规约"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#git-提交规约"}},[e._v("#")]),e._v(" Git 提交规约")]),e._v(" "),t("h3",{attrs:{id:"格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#格式"}},[e._v("#")]),e._v(" 格式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<type>[scope]: <subject>\n// 空一行\n[body]\n// 空一行\n[footer]\n")])])]),t("p",[t("strong",[e._v("注：[]代表可选，<>代表必选。")])]),e._v(" "),t("h3",{attrs:{id:"type"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#type"}},[e._v("#")]),e._v(" type")]),e._v(" "),t("p",[e._v("必填，用于指定 commit 的类型。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("feat：增加新功能\nfix：修复 bug\ndocs：只改动了文档相关的内容\nstyle：格式修改，没有修改代码逻辑，比如格式化、换行等\nrefactor：重构代码，既没有新增功能，也没有修复 bug，比如提取某段代码为一个方法、重构某个功能等\nperf：性能、体验优化等\ntest：新增 test 用例或修改现有测试用例\nbuild：构造工具的或者外部依赖的改动，比如 maven\nci：与 CI（持续集成服务）有关的改动\nchore：不修改 src 或者 test 的其余修改，例如构建过程或辅助工具的变动\nrevert：执行 git revert 打印的 message\n")])])]),t("p",[t("strong",[e._v("当同时有feat、fix和其他类型时，类型取feat、fix。")])]),e._v(" "),t("h3",{attrs:{id:"scope"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#scope"}},[e._v("#")]),e._v(" scope")]),e._v(" "),t("p",[e._v("非必填，用于描述改动的范围，格式一般为项目名/模块名，如果一次 commit 修改多个模块，建议拆分成多次 commit，以便更好追踪和维护。")]),e._v(" "),t("h3",{attrs:{id:"subject"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#subject"}},[e._v("#")]),e._v(" subject")]),e._v(" "),t("p",[e._v("必填，此次提交的简短描述，动词开头，第一人称现在时，比如add，而不用 added、adds，第一个字母小写，句尾不加句号（.）")]),e._v(" "),t("h3",{attrs:{id:"body"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#body"}},[e._v("#")]),e._v(" body")]),e._v(" "),t("p",[e._v("非必填，此次提交的详细描述，主要描述改动之前的情况及修改动机，对于小的修改不作要求，但是重大需求、更新等必须添加body来作说明。")]),e._v(" "),t("h3",{attrs:{id:"footer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#footer"}},[e._v("#")]),e._v(" footer")]),e._v(" "),t("p",[e._v("footer只用于以下两种情况")]),e._v(" "),t("ul",[t("li",[e._v("break changes")])]),e._v(" "),t("p",[e._v("break changes 指明是否产生了破坏性修改，涉及 break changes 的改动必须指明该项，类似版本升级、接口参数减少、接口删除、迁移等，以"),t("code",[e._v("BREAKING CHANGE：")]),e._v("开头，后面是变动的描述、变动的理由以及迁移的方法。")]),e._v(" "),t("ul",[t("li",[e._v("关闭 issue")])]),e._v(" "),t("p",[e._v("当前提交修改了某个 issue")]),e._v(" "),t("h3",{attrs:{id:"示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#示例"}},[e._v("#")]),e._v(" 示例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fix(ngStyle): correctly remove old style when new style value is invalid\n\nSince d6098ee, old styles were not removed if `newStyles` specified an\ninvalid value for the style (e.g. `false`). The assumption was that the\nnew style would overwrite the old style value, but using an invalid\nvalue made browsers ignore the new value and thus keep the old style.\nThis would typically happen when guarding a style with a boolean flag;\ne.g.: `ng-style=\"{backgroundColor: isError && 'red'}\"`\n\nThis commit essentially revers commit d6098ee, whose main purpose was\nto work around jquery/jquery#4185. The jQuery issue has been fixed in\n3.4.0, so that should not be a problem any more.\n\nFixes #16860\n\nCloses #16868\n")])])]),t("h2",{attrs:{id:"java-代码格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-代码格式"}},[e._v("#")]),e._v(" Java 代码格式")]),e._v(" "),t("p",[e._v("Java 代码格式在遵循 "),t("a",{attrs:{href:"https://google.github.io/styleguide/javaguide.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Google Java Style Guide"),t("OutboundLink")],1),e._v(" 的基础上，采用 Alibaba"),t("code",[e._v("4")]),e._v("个空格缩进的规约（谷歌默认采用的是"),t("code",[e._v("2")]),e._v("个空格的缩进）。")]),e._v(" "),t("p",[e._v("IntelliJ IDEA 中导入（"),t("code",[e._v("Preferences")]),e._v(" -> "),t("code",[e._v("Editor")]),e._v(" -> "),t("code",[e._v("Code Style")]),e._v(" -> "),t("code",[e._v("Java")]),e._v(" -> "),t("code",[e._v("Schema")]),e._v(" -> "),t("code",[e._v("Import Schema")]),e._v("）以下格式文件：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<?xml version="1.0" encoding="UTF-8"?>\n<code_scheme name="GoogleStyle">\n\n    <codeStyleSettings language="JAVA">\n        <option name="KEEP_CONTROL_STATEMENT_IN_ONE_LINE" value="false"/>\n        <option name="KEEP_BLANK_LINES_IN_CODE" value="1"/>\n        <option name="BLANK_LINES_AFTER_CLASS_HEADER" value="1"/>\n        <option name="ALIGN_MULTILINE_PARAMETERS" value="false"/>\n        <option name="ALIGN_MULTILINE_RESOURCES" value="false"/>\n        <option name="ALIGN_MULTILINE_FOR" value="false"/>\n        <option name="CALL_PARAMETERS_WRAP" value="1"/>\n        <option name="METHOD_PARAMETERS_WRAP" value="1"/>\n        <option name="EXTENDS_LIST_WRAP" value="1"/>\n        <option name="THROWS_KEYWORD_WRAP" value="1"/>\n        <option name="METHOD_CALL_CHAIN_WRAP" value="1"/>\n        <option name="BINARY_OPERATION_WRAP" value="1"/>\n        <option name="BINARY_OPERATION_SIGN_ON_NEXT_LINE" value="true"/>\n        <option name="TERNARY_OPERATION_WRAP" value="1"/>\n        <option name="TERNARY_OPERATION_SIGNS_ON_NEXT_LINE" value="true"/>\n        <option name="FOR_STATEMENT_WRAP" value="1"/>\n        <option name="ARRAY_INITIALIZER_WRAP" value="1"/>\n        <option name="WRAP_COMMENTS" value="true"/>\n        <option name="IF_BRACE_FORCE" value="3"/>\n        <option name="DOWHILE_BRACE_FORCE" value="3"/>\n        <option name="WHILE_BRACE_FORCE" value="3"/>\n        <option name="FOR_BRACE_FORCE" value="3"/>\n        <option name="PARENT_SETTINGS_INSTALLED" value="true"/>\n        <indentOptions>\n            <option name="INDENT_SIZE" value="4"/>\n            <option name="CONTINUATION_INDENT_SIZE" value="4"/>\n            <option name="TAB_SIZE" value="4"/>\n        </indentOptions>\n    </codeStyleSettings>\n\n</code_scheme>\n')])])]),t("h2",{attrs:{id:"接口调试利器-easyyapi-插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口调试利器-easyyapi-插件"}},[e._v("#")]),e._v(" 接口调试利器 EasyYapi 插件")]),e._v(" "),t("p",[e._v("IntelliJ IDEA 的 EasyYapi 插件是一个基于 javadoc & KDoc & ScalaDoc 解析 API 文档的插件，可以在保持代码零侵入的情况下得到相当完整的 api 文档（特殊的需求还是需要部分特殊的注释/注解配合），支持导出文件中的 API 到"),t("code",[e._v("yapi")]),e._v("/"),t("code",[e._v("postman")]),e._v("/"),t("code",[e._v("markdown")]),e._v("，以及"),t("code",[e._v("在 IDEA 中直接发起文件中的 API 请求进行接口调试")]),e._v("。")]),e._v(" "),t("p",[e._v("如果是 Spring 项目，我们可以选中一个或多个 "),t("code",[e._v("@Controller")]),e._v(" 的 "),t("code",[e._v(".java")]),e._v(" 文件来批量生成需要调试的接口，效果如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/more/api10.png",alt:""}})]),e._v(" "),t("p",[e._v("首先，我们需要在 IntelliJ IDEA 的插件市场中搜索并安装 EasyYapi 插件，安装成功后需要重启 IDEA：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/more/api0.png",alt:""}})]),e._v(" "),t("p",[e._v("然后，选中需要调试的 API 文件，鼠标右键选择"),t("code",[e._v("Call Api")]),e._v("即可打开接口调试窗口对选中文件中的 API 发起请求进行接口调试。打开调试窗口后，我们选中用户登录接口，如下所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/more/api1.png",alt:""}})]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/more/api2.png",alt:""}})]),e._v(" "),t("p",[e._v("从上图可以看出，接口请求路径和请求数据格式都已经自动生成好了，我们只需要修改调试数据，然后点击运行按钮来发起 API 请求：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/more/api4.png",alt:""}})]),e._v(" "),t("p",[e._v("如果我们要导出文件中的 API 到 "),t("code",[e._v("Yapi")]),e._v("/"),t("code",[e._v("Postman")]),e._v("/"),t("code",[e._v("Markdown")]),e._v("，需要选中一个或多个 "),t("code",[e._v("@Controller")]),e._v(" 的 "),t("code",[e._v(".java")]),e._v(" 文件然后鼠标右键选择"),t("code",[e._v("Export Api")]),e._v("（也可以直接选择"),t("code",[e._v("Export Yapi")]),e._v("/"),t("code",[e._v("Export Postman")]),e._v("/"),t("code",[e._v("Export Markdown")]),e._v("），如下所示:")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/more/api5.png",alt:""}})]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/more/api6.png",alt:""}})]),e._v(" "),t("p",[e._v("生成的"),t("code",[e._v("Markdown")]),e._v("API 文档效果如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/more/api7.png",alt:""}})]),e._v(" "),t("h2",{attrs:{id:"mysql-官方多线程逻辑备份工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-官方多线程逻辑备份工具"}},[e._v("#")]),e._v(" MySQL 官方多线程逻辑备份工具")]),e._v(" "),t("h3",{attrs:{id:"介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://dev.mysql.com/doc/mysql-shell/8.0/en",target:"_blank",rel:"noopener noreferrer"}},[e._v("MySQL Shell"),t("OutboundLink")],1),e._v("是 MySQL 的高级命令行客户端和代码编辑器。除了 SQL，MySQL Shell 还为 JavaScript 和 Python 提供脚本功能。当 MySQL Shell 通过 X 协议连接到 MySQL 服务器时，X DevAPI 可用于处理关系数据和文档数据。")]),e._v(" "),t("p",[e._v("MySQL Shell 8.0.21 包括一些新的易用、高性能和集成的工具（MySQL Shell Dump & Dump Loading Utility）用来创建逻辑转储和执行逻辑还原。该序列工具以  MySQL Shell 8.0.17 中引入的多线程 CSV 导入工具 util.importTable() 为基础构建以便轻松转储和加载整个数据库实例或一组 schema。该序列工具包括：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("util.dumpInstance()：转储整个数据库实例，包括用户")])]),e._v(" "),t("li",[t("p",[e._v("util.dumpSchemas()：转储一组数据库 schema")])]),e._v(" "),t("li",[t("p",[e._v("util.loadDump()：将转储加载到目标数据库中")])])]),e._v(" "),t("p",[e._v("主要特色功能包括：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("多线程转储，将较大的表分成较小的块，速度高达 3GB / s")])]),e._v(" "),t("li",[t("p",[e._v("并行加载块，结合 MySQL Server 8.0.21 中的禁用 InnoDB Redo Log 的功能，加载性能可以超过 200MB / s")])]),e._v(" "),t("li",[t("p",[e._v("在转储的同时进行加载")])]),e._v(" "),t("li",[t("p",[e._v("中断后继续加载数据（断点续传）")])]),e._v(" "),t("li",[t("p",[e._v("内置压缩（zstd 和 gzip）")])]),e._v(" "),t("li",[t("p",[e._v("加载数据后推迟二级索引的创建")])]),e._v(" "),t("li",[t("p",[e._v("直接从 OCI 对象存储中转储和加载")])]),e._v(" "),t("li",[t("p",[e._v("兼容 OCI 的 MySQL 数据库服务模式，使得向云的迁移变得容易")])])]),e._v(" "),t("h3",{attrs:{id:"mysql-shell-安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mysql-shell-安装"}},[e._v("#")]),e._v(" MySQL Shell 安装")]),e._v(" "),t("p",[e._v("MySQL Shell 提供了 Windows、Linux 和  Mac 的安装支持，具体请查看如下的官方安装文档：")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-install.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-install.html"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"dump-dump-loading-utility"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dump-dump-loading-utility"}},[e._v("#")]),e._v(" Dump & Dump Loading Utility")]),e._v(" "),t("p",[e._v("MySQL Shell Dump & Dump Loading Utility 的使用以及与其它各种主流逻辑转储和加载工具 mysqldump,、mysqlpump 和 mydumper 的比较结果如下：")]),e._v(" "),t("ul",[t("li",[e._v("数据以大约 256 MB 的块形式转储")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('mysqlsh-js> util.dumpSchemas(["<db>"], \n                             "<directory>",\n                             {threads: 88, \n                             bytesPerChunk: "256M"})\n')])])]),t("p",[t("img",{attrs:{src:"/img/more/dump.png",alt:"转存"}})]),e._v(" "),t("ul",[t("li",[e._v("加载")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('mysqlsh-js> util.loadDump("<directory>", \n                          {threads: 88})\n')])])]),t("p",[t("img",{attrs:{src:"/img/more/load.png",alt:"加载"}})]),e._v(" "),t("p",[e._v("Redo Log 禁用的情况下，MySQL Shell 能够快速转储数据，高达近 "),t("code",[e._v("3GB/s")]),e._v("，并以 "),t("code",[e._v("200MB/s")]),e._v(" 以上的速度加载数据。")]),e._v(" "),t("h3",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),t("p",[e._v("[1] "),t("a",{attrs:{href:"https://dev.mysql.com/blog-archive/mysql-shell-dump-load-part-1-demo",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://dev.mysql.com/blog-archive/mysql-shell-dump-load-part-1-demo"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("[2] "),t("a",{attrs:{href:"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-utilities-dump-instance-schema.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-utilities-dump-instance-schema.html"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("[3] "),t("a",{attrs:{href:"https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-utilities-load-dump.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-utilities-load-dump.html"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"shell-基础操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shell-基础操作"}},[e._v("#")]),e._v(" Shell 基础操作")]),e._v(" "),t("blockquote",[t("p",[e._v("在计算机科学中，Shell 俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（command interpreter，命令解析器），它接收用户命令，然后调用相应的应用程序。")])]),e._v(" "),t("blockquote",[t("p",[e._v("Shell 同时也是一种程序设计语言。作为命令语言，它交互式解释和执行用户输入的命令或者自动地解释和执行预先设定好的一连串的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。")])]),e._v(" "),t("p",[e._v("在 Linux/Unix 平台上，Shell 一般默认为 Bash Shell，也有其他 Shell，比如 C Shell 等；Mac 平台，从 Catalina 版本开始，默认 Shell 从 Bash 改为 Zsh；Windows 平台上，Shell = CMD（Command Shell 的简写，也叫做命令提示符）。")]),e._v(" "),t("p",[e._v("Mac 平台通过 terminal.app、Windows 平台通过 cmd.exe 来运行 shell。")]),e._v(" "),t("p",[e._v("在 Linux/Mac 上，通过如下命令查看当前系统所有的 shell：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("cat /etc/shells\n")])])]),t("p",[e._v("结果如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("# List of acceptable shells for chpass(1).\n# Ftpd will not allow users to connect who are not using\n# one of these shells.\n\n/bin/bash\n/bin/csh\n/bin/dash\n/bin/ksh\n/bin/sh\n/bin/tcsh\n/bin/zsh\n")])])]),t("p",[e._v("查看当前使用的 shell：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("echo $0\n")])])]),t("p",[e._v("结果如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("-zsh\n")])])]),t("p",[e._v("修改系统默认 shell 为 bash:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("chsh -s /bin/bash\n")])])]),t("p",[e._v("查看结果（需要重启终端）：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("xiongxiangdeAir:~ xiongxiaoyang$ echo $0\n-bash\n")])])]),t("h3",{attrs:{id:"切换目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#切换目录"}},[e._v("#")]),e._v(" 切换目录")]),e._v(" "),t("p",[e._v("无论是 Linux 平台、Mac 平台还是 Windows 平台，都是通过 "),t("code",[e._v("cd")]),e._v("+目录名进入目录， "),t("code",[e._v("cd ..")]),e._v("返回上级目录。我们还可以通过"),t("code",[e._v("pushd")]),e._v("+目录名进入新目录同时记住之前的目录名，之后可以使用 "),t("code",[e._v("popd")]),e._v(" 返回之前的目录。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("xiongxiaoyang@xiongxiangdeAir ~ % pushd java/novel\n~/java/novel ~\nxiongxiaoyang@xiongxiangdeAir novel % popd\n~\nxiongxiaoyang@xiongxiangdeAir ~ % \n")])])]),t("h3",{attrs:{id:"目录列表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录列表"}},[e._v("#")]),e._v(" 目录列表")]),e._v(" "),t("p",[e._v("Linux/Mac 平台通过"),t("code",[e._v("ls")]),e._v("命令查看当前目录下的所有文件和子目录，Windows 平台通过"),t("code",[e._v("dir")]),e._v("命令查看。可以使用通配符"),t("code",[e._v("*")]),e._v("对显示的内容进行过滤。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("xiongxiaoyang@xiongxiangdeAir manager % ls *Cache*.java\nAuthorInfoCacheManager.java\tBookRankCacheManager.java\nBookCategoryCacheManager.java\tFriendLinkCacheManager.java\nBookChapterCacheManager.java\tHomeBookCacheManager.java\nBookContentCacheManager.java\tNewsCacheManager.java\nBookInfoCacheManager.java\tUserInfoCacheManager.java\n")])])]),t("h3",{attrs:{id:"新建目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#新建目录"}},[e._v("#")]),e._v(" 新建目录")]),e._v(" "),t("p",[e._v("Linux/Mac 平台通过"),t("code",[e._v("mkdir")]),e._v("命令新建目录，Windows 平台通过"),t("code",[e._v("md")]),e._v("命令新建目录。")]),e._v(" "),t("h3",{attrs:{id:"删除文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除文件"}},[e._v("#")]),e._v(" 删除文件")]),e._v(" "),t("p",[e._v("Linux/Mac 平台通过"),t("code",[e._v("rm")]),e._v("+文件名删除文件，Windows 平台通过"),t("code",[e._v("del")]),e._v("+文件名删除文件。")]),e._v(" "),t("h3",{attrs:{id:"删除目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除目录"}},[e._v("#")]),e._v(" 删除目录")]),e._v(" "),t("p",[e._v("Linux/Mac 平台通过"),t("code",[e._v("rm -r")]),e._v("命令删除目录及其包含的所有文件，Windows 平台通过"),t("code",[e._v("deltree")]),e._v("命令实现。")]),e._v(" "),t("h3",{attrs:{id:"重复命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重复命令"}},[e._v("#")]),e._v(" 重复命令")]),e._v(" "),t("p",[e._v("所有平台都可以通过"),t("code",[e._v("⬆️")]),e._v("键来显示上一条命令，Linux/Mac 平台可以通过"),t("code",[e._v("!!")]),e._v("来执行上一条命令，"),t("code",[e._v("!n")]),e._v("来执行第 n 条命令。")]),e._v(" "),t("h3",{attrs:{id:"命令历史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命令历史"}},[e._v("#")]),e._v(" 命令历史")]),e._v(" "),t("p",[e._v("Linux/Mac 平台通过 "),t("code",[e._v("history")]),e._v("命令来查看所有使用过的命令，Windows 平台通过"),t("code",[e._v("F7")]),e._v("键来实现。Linux/Mac 平台还会显示历史序号，这样就可以通过上面的"),t("code",[e._v("!n")]),e._v("命令来方便重复执行。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("xiongxiaoyang@xiongxiangdeAir bin % history\n  992  ls\n  993  cd front\n  994  ls\n  995  cd ../../manager\n  996  ls\n  997  ls *Cache*.java\n  998  chsh -s /bin/bash\n  999  echo $0\n 1000  echo $0\n 1001  cd java/novel-plus/novel-front/target/build/bin\n 1002  start.sh\n 1003  ls\n 1004  ll\n 1005  chsh -s /bin/bash\n 1006  ls\n 1007  ll\n\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("xiongxiaoyang@xiongxiangdeAir bin % !1006\nls\nreadme.txt\t\tstop.sh\nstart.sh\t\twindows-start.bat\n")])])]),t("h3",{attrs:{id:"解压文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解压文件"}},[e._v("#")]),e._v(" 解压文件")]),e._v(" "),t("p",[e._v("Linux/Mac 平台通过"),t("code",[e._v("unzip")]),e._v("命令来解压"),t("code",[e._v(".zip")]),e._v("后缀的压缩包文件，Windows 平台需要通过互联网安装"),t("code",[e._v("unzip")]),e._v("命令。")]),e._v(" "),t("p",[e._v("...")]),e._v(" "),t("p",[e._v("更多 shell 命令请搜索 "),t("code",[e._v("Windows Shell")]),e._v(" 或 "),t("code",[e._v("Bash Shell")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"integer-valueof-的享元模式应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#integer-valueof-的享元模式应用"}},[e._v("#")]),e._v(" Integer.valueOf() 的享元模式应用")]),e._v(" "),t("p",[e._v("在 Java 中，如果我们想要创建一个 Integer 对象，一般有以下三种方式：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("通过标准对象创建语法 new Interger(int) 来创建")])]),e._v(" "),t("li",[t("p",[e._v("通过静态工厂 Integer.valueOf(int) 来创建")])]),e._v(" "),t("li",[t("p",[e._v("通过自动装箱将基本类型 int 自动转换为包装类型 Integer，这其实是通过对 Integer.valueOf() 的自动调用来完成的")])])]),e._v(" "),t("p",[e._v("方式 1 和方式 3 本质上没有什么区别，只不过方式 1 看起来更简洁，那么方式 1 和方式 2 有什么区别呢？先来看一个经典的面试题：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public static void main(String[] args) { \n    Integer m = Integer.valueOf(111);  \n    Integer n = Integer.valueOf(111);  \n    System.out.println(m == n);\n\n    m = new Integer(111);  \n    n = new Integer(111);  \n    System.out.println(m == n);   \n  \n    Integer i = Integer.valueOf(222);    \n    Integer j = Integer.valueOf(222);   \n    System.out.println(i == j);\n   \n    i = new Integer(222);  \n    j = new Integer(222);   \n    System.out.println(i == j);\n}\n")])])]),t("p",[e._v("大家可以不急着看答案，先独立思考一下以上的打印结果。我想刷过面试题的同学答对这道题应该问题不大，并且能够知道一些原因。但是真正深入了解源码，以及背后设计思想的同学应该也不是很多。我们先来看看构造函数 Interger(int) 的源码（JDK 17），如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private final int value;\n@Deprecated(since="9", forRemoval = true)\npublic Integer(int value) {\n    this.value = value;\n}\n')])])]),t("p",[e._v("使用 new 关键字创建对象会自动调用该对象的相应构造函数，从以上源码中可以看出，Interger(int) 构造函数只做一件事，那就是初始化成员常量 value 的值，该常量代表了 Integer 对象的值。")]),e._v(" "),t("p",[e._v("使用 new 关键字每次都会在堆内存上开辟一块新的空间用于存放创建出来的对象，只要使用了 new 关键字那么创建出来的对象就是新的对象，而 "),t("code",[e._v("==")]),e._v(" 关系操作符比较的是两个对象之间的引用是否相等（即是否引用了同一个对象），所以使用 new 创建的每一个 Integer 对象使用"),t("code",[e._v("==")]),e._v(" 关系操作符得到的结果都是"),t("code",[e._v("false")]),e._v("。")]),e._v(" "),t("p",[e._v("我们再来看看静态工厂 Integer.valueOf(int) 的源码（JDK 17），如下所示：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private static class IntegerCache {\n    static final int low = -128;\n    static final int high;\n    static final Integer[] cache;\n    static Integer[] archivedCache;\n\n    static {\n        // high value may be configured by property\n        int h = 127;\n        String integerCacheHighPropValue =\n            VM.getSavedProperty("java.lang.Integer.IntegerCache.high");\n        if (integerCacheHighPropValue != null) {\n            try {\n                h = Math.max(parseInt(integerCacheHighPropValue), 127);\n                // Maximum array size is Integer.MAX_VALUE\n                h = Math.min(h, Integer.MAX_VALUE - (-low) -1);\n            } catch( NumberFormatException nfe) {\n                // If the property cannot be parsed into an int, ignore it.\n            }\n        }\n        high = h;\n\n        // Load IntegerCache.archivedCache from archive, if possible\n        CDS.initializeFromArchive(IntegerCache.class);\n        int size = (high - low) + 1;\n\n        // Use the archived cache if it exists and is large enough\n        if (archivedCache == null || size > archivedCache.length) {\n            Integer[] c = new Integer[size];\n            int j = low;\n            for(int i = 0; i < c.length; i++) {\n                c[i] = new Integer(j++);\n            }\n            archivedCache = c;\n        }\n        cache = archivedCache;\n        // range [-128, 127] must be interned (JLS7 5.1.7)\n        assert IntegerCache.high >= 127;\n    }\n\n    private IntegerCache() {}\n}\n@IntrinsicCandidate\npublic static Integer valueOf(int i) {\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\n        return IntegerCache.cache[i + (-IntegerCache.low)];\n    return new Integer(i);\n}\n')])])]),t("p",[e._v("从以上源码可以看出，Integer 类中包含一个私有的静态类 IntegerCache，该类是一个 Integer 对象数组（默认 -128 ～ 127）的缓存，缓存在第一次使用时被初始化，缓存的大小（Integer 缓存对象的最大值）可以由 JVM 参数"),t("code",[e._v("-XX:AutoBoxCacheMax=<size>")]),e._v(" 或系统属性"),t("code",[e._v("-Djava.lang.Integer.IntegerCache.high=<size>")]),e._v("来设置。")]),e._v(" "),t("p",[e._v("如果我们通过静态工厂 Integer.valueOf(int) 来创建 Integer 对象，首先会判断创建的对象值是否在 IntegerCache 中有缓存，有的话直接取缓存中的值，否则通过标准对象创建语法 new Interger(int) 创建并返回。")]),e._v(" "),t("p",[e._v("所以默认情况下，如果使用 Integer.valueOf(int) 创建的 Integer 对象值在 -128 ～ 127 之间，那么无论创建多少次，创建的每一个对象使用"),t("code",[e._v("==")]),e._v(" 关系操作符得到的结果都是"),t("code",[e._v("true")]),e._v("，否则都是"),t("code",[e._v("false")]),e._v("。")]),e._v(" "),t("p",[t("strong",[e._v("注：如果修改过"),t("code",[e._v("java.lang.Integer.IntegerCache.high")]),e._v("属性值，那么结果就另当别论了。")])]),e._v(" "),t("p",[e._v("静态工厂 Integer.valueOf(int) 的设计正是对享元模式的应用。享元模式定义如下：")]),e._v(" "),t("blockquote",[t("p",[e._v("享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。")])]),e._v(" "),t("blockquote",[t("p",[e._v("享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。")])]),e._v(" "),t("p",[e._v("Integer.valueOf(int) 通过享元模式缓存频繁请求的值来显着提高空间和时间性能，效率远远高于通过 new Integer() 创建对象的方式。所以 Java 9 中直接弃用了new Integer()，我们以后在创建 Integer 的包装类型时，也尽量不要再使用 new Integer() 的方式了。")]),e._v(" "),t("p",[t("strong",[e._v("注：其它包装类型（Long、Short 等）也类似。")])])])}),[],!1,null,null,null);a.default=s.exports}}]);